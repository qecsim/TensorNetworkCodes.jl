var documenterSearchIndex = {"docs":
[{"location":"api/plotting_functions/#Plotting-functions","page":"Plotting functions","title":"Plotting functions","text":"","category":"section"},{"location":"api/plotting_functions/","page":"Plotting functions","title":"Plotting functions","text":"Functions for plotting tensor-network codes and operators.","category":"page"},{"location":"api/plotting_functions/","page":"Plotting functions","title":"Plotting functions","text":"plot_code\nplot_operator","category":"page"},{"location":"api/plotting_functions/#TensorNetworkCodes.plot_code","page":"Plotting functions","title":"TensorNetworkCodes.plot_code","text":"plot_code(code::TensorNetworkCode; use_coords=true)\n\nReturn a plot, as returned by GraphPlot.gplot, of the code. If used in a Jupyter notebook the plot is rendered after the cell.\n\nPhysical qubit nodes are coloured red and virtual tensors are coloured green or blue:  green if they have no logical qubits and blue if they do.\n\nExamples\n\njulia> code = TensorNetworkCode(five_qubit_code());\n\njulia> plot_code(code)\n\n(Image: code plot)\n\n\n\n\n\n","category":"function"},{"location":"api/plotting_functions/#TensorNetworkCodes.plot_operator","page":"Plotting functions","title":"TensorNetworkCodes.plot_operator","text":"plot_operator(code::TensorNetworkCode, operator::AbstractVector{Int}; use_coords=true)\n\nReturn a plot, as returned by GraphPlot.gplot, of the operator. If used in a Jupyter notebook the plot is rendered after the cell.\n\nExamples\n\njulia> code = TensorNetworkCode(steane_code());\n\njulia> plot_operator(code, code.stabilizers[1])\n\n(Image: operator plot)\n\n\n\n\n\n","category":"function"},{"location":"api/itensors_functions/#ITensors-functions","page":"ITensors functions","title":"ITensors functions","text":"","category":"section"},{"location":"api/itensors_functions/","page":"ITensors functions","title":"ITensors functions","text":"Utility ITensors functions typically used by the TNDecode module and the TNDistance module.","category":"page"},{"location":"api/itensors_functions/","page":"ITensors functions","title":"ITensors functions","text":"code_to_Itensor\nidentity_coset\nall_cosets\nphysical_tensor\ncreate_virtual_tensor","category":"page"},{"location":"api/itensors_functions/#TensorNetworkCodes.code_to_Itensor","page":"ITensors functions","title":"TensorNetworkCodes.code_to_Itensor","text":"code_to_Itensor(code::QuantumCode,logical_indices::Array{Index{Int64},1},physical_indices::Array{Index{Int64},1})\n-> ITensor\n\nReturns an ITensor describing the logical cosets of the code.  Indices  (Index{Int64}) correspond to logical and physical qubits of the code.\n\nExamples\n\njulia> using ITensors;\n\njulia> logical_indices = [Index(4,\"logical\")];\n\njulia> physical_indices = [Index(4,\"physical\") for _ in 1:5];\n\njulia> tensor = code_to_Itensor(five_qubit_surface_code(),logical_indices,physical_indices);\n\njulia> dims(tensor) # tensor has six legs\n(4, 4, 4, 4, 4, 4)\n\n\n\n\n\n","category":"function"},{"location":"api/itensors_functions/#TensorNetworkCodes.identity_coset","page":"ITensors functions","title":"TensorNetworkCodes.identity_coset","text":"identity_coset(tensor::ITensor) -> ITensor\n\nGiven an ITensor descibing a code, return the ITensor describing only the identity coset, i.e., the stabilizer group.\n\nExamples\n\njulia> using ITensors;\n\njulia> logical_indices = [Index(4,\"logical\")];\n\njulia> physical_indices = [Index(4,\"physical\") for _ in 1:7];\n\njulia> tensor = code_to_Itensor(steane_code(),logical_indices,physical_indices);\n\njulia> sum(identity_coset(tensor)) # stabilizer group has 64 elements\n64.0\n\n\n\n\n\n","category":"function"},{"location":"api/itensors_functions/#TensorNetworkCodes.all_cosets","page":"ITensors functions","title":"TensorNetworkCodes.all_cosets","text":"all_cosets(tensor::ITensor) -> ITensor\n\nGiven an ITensor descibing a code, return the ITensor describing all the cosets by summing over all logical indices.  Works similarly to  identity_coset.\n\n\n\n\n\n","category":"function"},{"location":"api/itensors_functions/#TensorNetworkCodes.physical_tensor","page":"ITensors functions","title":"TensorNetworkCodes.physical_tensor","text":"physical_tensor(index::Index{Int64},error_prob::Float64,pauli::Int64) -> ITensor\n\nReturns a one leg ITensor describing the error on one physical qubit. Assumes depolarizing noise as the error model.  pauli permutes the values (useful for making decoders to account for pure_errors).\n\nExamples\n\njulia> using ITensors;\n\njulia> index = Index(4,\"physical\");\n\njulia> pauli = 0;\n\njulia> error_prob = 0.3;\n\njulia> a = array(physical_tensor(index,error_prob,pauli));\n\njulia> println(round.(a,digits=1))\n[0.7, 0.1, 0.1, 0.1]\n\njulia> pauli = 2;\n\njulia> a = array(physical_tensor(index,error_prob,pauli));\n\njulia> println(round.(a,digits=1))\n[0.1, 0.1, 0.7, 0.1]\n\n\n\n\n\n","category":"function"},{"location":"api/itensors_functions/#TensorNetworkCodes.create_virtual_tensor","page":"ITensors functions","title":"TensorNetworkCodes.create_virtual_tensor","text":"create_virtual_tensor(code::TensorNetworkCode,node::Int64) -> ITensor\n\nCreates the ITensor describing the seed code at node.  Necessary for, e.g., tensor-network decoding or distance calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/TNDecode/#TNDecode-module","page":"TNDecode module","title":"TNDecode module","text":"","category":"section"},{"location":"api/TNDecode/","page":"TNDecode module","title":"TNDecode module","text":"CurrentModule = TensorNetworkCodes.TNDecode","category":"page"},{"location":"api/TNDecode/","page":"TNDecode module","title":"TNDecode module","text":"TNDecode\nTNDecode.basic_contract\nTNDecode.mps_contract\nTNDecode.tn_decode","category":"page"},{"location":"api/TNDecode/#TensorNetworkCodes.TNDecode","page":"TNDecode module","title":"TensorNetworkCodes.TNDecode","text":"Decoding functions based on contracting a tensor-network associated with a TensorNetworkCode, see tn_decode.\n\n\n\n\n\n","category":"module"},{"location":"api/TNDecode/#TensorNetworkCodes.TNDecode.basic_contract","page":"TNDecode module","title":"TensorNetworkCodes.TNDecode.basic_contract","text":"basic_contract(bond_dim=10) -> function\n\nReturn an exact contract function for use with tn_decode that contracts a matrix of ITensor working along row-by-row.\n\nSee also: tn_decode.\n\n\n\n\n\n","category":"function"},{"location":"api/TNDecode/#TensorNetworkCodes.TNDecode.mps_contract","page":"TNDecode module","title":"TensorNetworkCodes.TNDecode.mps_contract","text":"mps_contract(bond_dim=10) -> function\n\nReturn a contract function for use with tn_decode that contracts a matrix of ITensor, treating rows as MPS/MPO and contracting rows element-wise, retaining a maximum bond dimension of bond_dim, before contracting along the final row.\n\nSee also: tn_decode.\n\n\n\n\n\n","category":"function"},{"location":"api/TNDecode/#TensorNetworkCodes.TNDecode.tn_decode","page":"TNDecode module","title":"TensorNetworkCodes.TNDecode.tn_decode","text":"tn_decode(\n    code::TensorNetworkCode, syndrome::AbstractVector{Int}, error_probability::Real;\n    contract_fn=basic_contract()\n) -> (Vector{Int}, Float64)\n\nReturn a recovery operator for the code, that is consistent with the syndrome and is from the most-likely logical coset. Additionally, the predicted success probability, defined as the ratio of the probability of the mostly-likely logical coset to the sum of the probabilities of all logical cosets, is returned.\n\nThe method of tensor-network contraction defaults to basic_contract, which corresponds to exact contraction. Alternatively, mps_contract may be specified for efficient but approximate contraction.\n\nSee also: basic_contract, mps_contract\n\nnote: Note\nThis function currently assumes a depolarizing noise model and only supports codes that can be laid out on a square lattice.\n\nExamples\n\njulia> using TensorNetworkCodes.TNDecode\n\njulia> code = rotated_surface_code(3);\n\njulia> error = [0, 0, 0, 1, 0, 0, 3, 0, 0];  # IIIXIIZII\n\njulia> syndrome = find_syndrome(code, error);\n\njulia> p = 0.2;  # error_probability\n\njulia> recovery, success_prob = tn_decode(code, syndrome, p; contract_fn=mps_contract(8))\n([0, 0, 0, 3, 3, 0, 1, 3, 0], 0.8250539267483997)\n\njulia> find_syndrome(code, recovery) == syndrome\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/example_codes/#Example-codes","page":"Example codes","title":"Example codes","text":"","category":"section"},{"location":"api/example_codes/#SimpleCode-examples","page":"Example codes","title":"SimpleCode examples","text":"","category":"section"},{"location":"api/example_codes/","page":"Example codes","title":"Example codes","text":"five_qubit_code\nfive_qubit_surface_code\nrandom_code\nrandom_stabilizer_state\nsteane_code","category":"page"},{"location":"api/example_codes/#TensorNetworkCodes.five_qubit_code","page":"Example codes","title":"TensorNetworkCodes.five_qubit_code","text":"five_qubit_code() -> SimpleCode\n\nReturn the five-qubit code.\n\n\n\n\n\n","category":"function"},{"location":"api/example_codes/#TensorNetworkCodes.five_qubit_surface_code","page":"Example codes","title":"TensorNetworkCodes.five_qubit_surface_code","text":"five_qubit_surface_code() -> SimpleCode\n\nReturn the five-qubit surface code.\n\n\n\n\n\n","category":"function"},{"location":"api/example_codes/#TensorNetworkCodes.random_code","page":"Example codes","title":"TensorNetworkCodes.random_code","text":"random_code(n::Int, k::Int) -> SimpleCode\n\nReturn a random code with n physical qubits and k logicals qubits.\n\nAn ErrorException is raised if k > n.\n\n\n\n\n\n","category":"function"},{"location":"api/example_codes/#TensorNetworkCodes.random_stabilizer_state","page":"Example codes","title":"TensorNetworkCodes.random_stabilizer_state","text":"random_stabilizer_state(n::Int) -> SimpleCode\n\nReturn a random code with n physical qubits and no logicals.\n\n\n\n\n\n","category":"function"},{"location":"api/example_codes/#TensorNetworkCodes.steane_code","page":"Example codes","title":"TensorNetworkCodes.steane_code","text":"steane_code() -> SimpleCode\n\nReturn the seven-qubit Steane code.\n\n\n\n\n\n","category":"function"},{"location":"api/example_codes/#TensorNetworkCode-examples","page":"Example codes","title":"TensorNetworkCode examples","text":"","category":"section"},{"location":"api/example_codes/","page":"Example codes","title":"Example codes","text":"almost_rotated_surface_code\nrotated_surface_code\nsurface_code","category":"page"},{"location":"api/example_codes/#TensorNetworkCodes.almost_rotated_surface_code","page":"Example codes","title":"TensorNetworkCodes.almost_rotated_surface_code","text":"almost_rotated_surface_code(\nL::Int64,\ninput_seed_code::SimpleCode,\ninput_coords::Array{Int64}) -> TensorNetworkCode\n\nGenerates a TensorNetworkCode that is almost the rotated surface code.  Requires the input_seed_code to have five qubits and to be in the bulk (input_coords with components not equal to 1 or L).\n\nExamples\n\njulia> code = almost_rotated_surface_code(3,five_qubit_code(),[2,2]);\n\njulia> verify(code) # try this out and check we get a real code\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/example_codes/#TensorNetworkCodes.rotated_surface_code","page":"Example codes","title":"TensorNetworkCodes.rotated_surface_code","text":"rotated_surface_code(L::Int64) -> TensorNetworkCode\n\nGenerates the LxL rotated surface code as a TensorNetworkCode.\n\nExamples\n\njulia> rot = rotated_surface_code(3);\n\njulia> pauli_weight(rot.stabilizers[2]) # weight of a plaquette stabilizer\n4\n\n\n\n\n\n","category":"function"},{"location":"api/example_codes/#TensorNetworkCodes.surface_code","page":"Example codes","title":"TensorNetworkCodes.surface_code","text":"surface_code(L::Int64)\n\nReturns an (L+1) x L surface code TensorNetworkCode.\n\nExamples\n\njulia> surf = surface_code(2);\n\njulia> dist = find_distance_logicals(surf)[1] # code distance\n3\n\n\n\n\n\n","category":"function"},{"location":"api/QecsimAdaptors/#QecsimAdaptors-module","page":"QecsimAdaptors module","title":"QecsimAdaptors module","text":"","category":"section"},{"location":"api/QecsimAdaptors/","page":"QecsimAdaptors module","title":"QecsimAdaptors module","text":"CurrentModule = TensorNetworkCodes.QecsimAdaptors","category":"page"},{"location":"api/QecsimAdaptors/","page":"QecsimAdaptors module","title":"QecsimAdaptors module","text":"QecsimAdaptors\nQecsimAdaptors.QecsimTNCode\nQecsimAdaptors.QecsimTNDecoder","category":"page"},{"location":"api/QecsimAdaptors/#TensorNetworkCodes.QecsimAdaptors","page":"QecsimAdaptors module","title":"TensorNetworkCodes.QecsimAdaptors","text":"Adaptors for using tensor-network codes within the Qecsim framework.\n\nCode, QecsimTNCode, and decoder, QecsimTNDecoder, implementations are provided to be used with Qecsim error models for QEC simulations using the Qecsim App module.\n\n\n\n\n\n","category":"module"},{"location":"api/QecsimAdaptors/#TensorNetworkCodes.QecsimAdaptors.QecsimTNCode","page":"QecsimAdaptors module","title":"TensorNetworkCodes.QecsimAdaptors.QecsimTNCode","text":"QecsimTNCode <: Qecsim.StabilizerCode\n\nQecsimTNCode(code::TensorNetworkCode; distance=missing, label=nothing)\n\nQecsim stabilizer code implementation based on a tensor-network code.\n\nPauli operators such as stabilizers and logicals are converted to Qecsim's format on construction. These are available via Qecsim API methods of the same name. The Qecsim nkd method returns calculated values for n (number of physical qubits) and k (number of logical qubits) and the given distance for d, if provided, otherwise missing. The Qecsim label method returns the given label, if provided, otherwise the label is constructed from [n,k,d].\n\nPublic fields:\n\ntn_code::TensorNetworkCode  # the given tensor-network code\n\nExamples\n\njulia> using TensorNetworkCodes.QecsimAdaptors\n\njulia> using Qecsim: label, nkd, validate\n\njulia> tn_code = TensorNetworkCode(five_qubit_code());\n\njulia> qs_code = QecsimTNCode(tn_code; distance=3);\n\njulia> label(qs_code)\n\"QecsimTNCode: [5,1,3]\"\n\njulia> nkd(qs_code)\n(5, 1, 3)\n\njulia> validate(qs_code)  # no error indicates success\n\n\n\n\n\n","category":"type"},{"location":"api/QecsimAdaptors/#TensorNetworkCodes.QecsimAdaptors.QecsimTNDecoder","page":"QecsimAdaptors module","title":"TensorNetworkCodes.QecsimAdaptors.QecsimTNDecoder","text":"QecsimTNDecoder <: Decoder\n\nQecsimTNDecoder(chi::Union{Nothing,Integer}=nothing)\n\nQesim decoder implementation based on the TNDecode module. A null value of chi corresponds to exact contraction, otherwise chi defines the bond dimension used in MPS/MPO contraction.\n\nAn ArgumentError is thrown if chi is not null or positive. The Qecsim label method returns a label constructed from chi. The Qecsim decode method expects the keyword argument p for error probability, which defaults to 0.1, and returns a DecodeResult object with custom_values containing the success probability. The success probability is defined as the ratio of the probability of the mostly-likely logical coset to the sum of the probabilities of all logical cosets, for example:\n\nDecodeResult.custom_values = [[0.92]] # e.g. where 0.92 is the success probability\n\nThe success probability is added to custom_values as a vector so that as Qecsim App.qec_run aggregates success probabilities over many runs it extends the vector rather than simply summing over values.\n\nnote: Note\nCurrently the TNDecode module only supports codes that can be laid out on a square lattice.\n\nExamples\n\njulia> using TensorNetworkCodes.QecsimAdaptors\n\njulia> using Qecsim, Qecsim.GenericModels\n\njulia> using Random:MersenneTwister  # use RNG for reproducible example\n\njulia> code = QecsimTNCode(rotated_surface_code(3); distance=3);\n\njulia> error_model = DepolarizingErrorModel();\n\njulia> decoder = QecsimTNDecoder(4);\n\njulia> label(decoder)\n\"QecsimTNDecoder (chi=4)\"\n\njulia> result = qec_run_once(code, error_model, decoder, 0.1, MersenneTwister(11))\nRunResult{Vector{Vector{Float64}}}(true, 1, Bool[0, 0], [[0.9249813981321253]])\n\njulia> success_flag = result.success\ntrue\n\njulia> success_probability = result.custom_values[1][1]\n0.9249813981321253\n\n\n\n\n\n","category":"type"},{"location":"api/code_functions/#Code-functions","page":"Code functions","title":"Code functions","text":"","category":"section"},{"location":"api/code_functions/","page":"Code functions","title":"Code functions","text":"QuantumCode functions for verifying, evaluating, transforming and contracting.","category":"page"},{"location":"api/code_functions/#Basic","page":"Code functions","title":"Basic","text":"","category":"section"},{"location":"api/code_functions/","page":"Code functions","title":"Code functions","text":"Functions for code properties or verification.","category":"page"},{"location":"api/code_functions/","page":"Code functions","title":"Code functions","text":"num_qubits\nverify","category":"page"},{"location":"api/code_functions/#TensorNetworkCodes.num_qubits","page":"Code functions","title":"TensorNetworkCodes.num_qubits","text":"num_qubits(code::QuantumCode) -> Int\n\nReturn the number of physical qubits of the code.\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#TensorNetworkCodes.verify","page":"Code functions","title":"TensorNetworkCodes.verify","text":"verify(code::QuantumCode; log_warn=true) -> Bool\n\nReturn true if the code satisfied the properties of a valid code, or false otherwise.  If the code is not valid and log_warn is true then a warning is logged with the specific reason.\n\nThe following checks are performed:\n\nNumber of stabilizers, pure errors and logicals are consistent.\nStabilizers are independent and mutually commute.\nPure errors anticommute with corresponding stabilizers and commute with other stabilizers.\nLogicals commute with stabilizers.\n\nThe following checks are not yet performed:\n\nLogical commutation relations.\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#Evaluation","page":"Code functions","title":"Evaluation","text":"","category":"section"},{"location":"api/code_functions/","page":"Code functions","title":"Code functions","text":"Functions to evaluate operators or syndromes.","category":"page"},{"location":"api/code_functions/","page":"Code functions","title":"Code functions","text":"find_distance_logicals\nfind_pure_error\nfind_pure_errors\nfind_syndrome","category":"page"},{"location":"api/code_functions/#TensorNetworkCodes.find_distance_logicals","page":"Code functions","title":"TensorNetworkCodes.find_distance_logicals","text":"find_distance_logicals(code::Quantum_code; max_distance=5) -> Int, Vector{Vector{Int}}\n\nReturn the distance of the code and all minimum-weight logical operators.\n\nThis method works by brute force. It searches for operators of increasing weight so it works well for low-distance codes but will be slow for high-distance codes. If during the search max_distance is exceeded then an ErrorException is thrown.\n\nExamples\n\njulia> d, ls = find_distance_logicals(five_qubit_code());\n\njulia> d, length(ls), ls[1]  # distance, number and example of minimum-weight logicals\n(3, 30, [1, 2, 1, 0, 0])\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#TensorNetworkCodes.find_pure_error","page":"Code functions","title":"TensorNetworkCodes.find_pure_error","text":"find_pure_error(code::QuantumCode, syndrome::AbstractVector{Int}) -> AbstractVector{Int}\n\nReturn a pure error which yields the given syndrome with the given code.\n\nThe pure error is formed from a product of code.pure_errors and is not unique nor necessarily the lowest-weight error corresponding to the syndrome.\n\nSee also find_syndrome.\n\nExamples\n\njulia> code = five_qubit_code();\n\njulia> syndrome = find_syndrome(code, [0, 1, 3, 0, 1])  # error = IXZIX\n4-element Vector{Int64}:\n 1\n 0\n 0\n 1\n\njulia> pure_error = find_pure_error(code, syndrome)\n5-element Vector{Int64}:\n 1\n 1\n 0\n 0\n 0\n\njulia> find_syndrome(code, pure_error) == syndrome\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#TensorNetworkCodes.find_pure_errors","page":"Code functions","title":"TensorNetworkCodes.find_pure_errors","text":"find_pure_errors(stabilizers::AbstractVector{<:AbstractVector{Int}})\n    -> Vector{Vector{Int}}\n\nReturn pure errors corresponding to a list of stabilizers, such that each pure error anticommutes with precisely one stabilizer and the order of pure errors respects that of the stabilizers.\n\nThis function is efficient but does not give lowest weight pure errors (you cannot have both of these properties). An ErrorException is thrown if the function cannot succeed; for example if the stabilizers are not linearly independent.\n\nExamples\n\njulia> stabilizers = [[1, 3, 3, 1, 0], [0, 1, 3, 3, 1], [1, 0, 1, 3, 3], [3, 1, 0, 1, 3]];\n\njulia> pure_errors = find_pure_errors(stabilizers)\n4-element Vector{Vector{Int64}}:\n [0, 1, 0, 0, 0]\n [1, 3, 0, 0, 0]\n [3, 1, 0, 0, 0]\n [1, 0, 0, 0, 0]\n\njulia> [pauli_commutation(s, p) for s in stabilizers, p in pure_errors]  # commutations\n4×4 Matrix{Int64}:\n 1  0  0  0\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#TensorNetworkCodes.find_syndrome","page":"Code functions","title":"TensorNetworkCodes.find_syndrome","text":"find_syndrome(code::QuantumCode, error::AbstractVector{Int}) -> AbstractVector{Int}\n\nReturn the syndrome yielded by the given error with the given code.\n\nThe syndrome is a list of 1 and 0 of the same length as code.stabilizers, where 1 indicates the error anticommutes with the corresponding stabilizer.\n\nSee also find_pure_error.\n\nExamples\n\njulia> syndrome = find_syndrome(five_qubit_code(), [0, 1, 3, 0, 1])  # error = IXZIX\n4-element Vector{Int64}:\n 1\n 0\n 0\n 1\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#Transformation","page":"Code functions","title":"Transformation","text":"","category":"section"},{"location":"api/code_functions/","page":"Code functions","title":"Code functions","text":"Functions to gauge, permute and purify codes.","category":"page"},{"location":"api/code_functions/","page":"Code functions","title":"Code functions","text":"gauge\npermute\npurify","category":"page"},{"location":"api/code_functions/#TensorNetworkCodes.gauge","page":"Code functions","title":"TensorNetworkCodes.gauge","text":"gauge(code::SimpleCode, logical_qubit::Int, logical_pauli::Int) -> SimpleCode\n\ngauge(code::TensorNetworkCode, logical_qubit::Int, logical_pauli::Int)\n    -> TensorNetworkCode\n\nGiven a code with k logicals on n physical qubits, return a new code with k - 1 logicals on n physical qubits by adding a logical operator as a stabilizer, where logical_qubit indexes which logical qubit is gauged and logical_pauli indicates which logical Pauli is added to the stabilizers.\n\nA ErrorException is thrown if logical_qubit indexes a non-existant logical qubit, or if logical_pauli is not in 1:3 (logical identity does not fix a gauge).\n\nExamples\n\njulia> code = five_qubit_code();\n\njulia> code.stabilizers\n4-element Vector{Vector{Int64}}:\n [1, 3, 3, 1, 0]\n [0, 1, 3, 3, 1]\n [1, 0, 1, 3, 3]\n [3, 1, 0, 1, 3]\n\njulia> code.logicals\n2-element Vector{Vector{Int64}}:\n [1, 1, 1, 1, 1]\n [3, 3, 3, 3, 3]\n\njulia> new_code = gauge(code, 1, 3);  # gauge logical qubit 1 using logical Z\n\njulia> new_code.stabilizers\n5-element Vector{Vector{Int64}}:\n [1, 3, 3, 1, 0]\n [0, 1, 3, 3, 1]\n [1, 0, 1, 3, 3]\n [3, 1, 0, 1, 3]\n [3, 3, 3, 3, 3]\n\njulia> new_code.logicals\nVector{Int64}[]\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#TensorNetworkCodes.permute","page":"Code functions","title":"TensorNetworkCodes.permute","text":"permute(code::SimpleCode, permutation) -> SimpleCode\n\nReturn a new simple code with the physical qubits permuted relative to the given code, according to the permutation.\n\nThe permutation is expected in the format used for Base.permute! and it is applied to each stabilizer, logical and pure error of the code. No checking is done to verify that permuation is a valid.\n\nExamples\n\njulia> code = five_qubit_code();\n\njulia> code.name\n\"Five qubit code\"\n\njulia> code.stabilizers\n4-element Vector{Vector{Int64}}:\n [1, 3, 3, 1, 0]\n [0, 1, 3, 3, 1]\n [1, 0, 1, 3, 3]\n [3, 1, 0, 1, 3]\n\njulia> new_code = permute(code, [2, 1, 3, 4, 5]);\n\njulia> new_code.name\n\"Five qubit code [2, 1, 3, 4, 5]\"\n\njulia> new_code.stabilizers\n4-element Vector{Vector{Int64}}:\n [3, 1, 3, 1, 0]\n [1, 0, 3, 3, 1]\n [0, 1, 1, 3, 3]\n [1, 3, 0, 1, 3]\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#TensorNetworkCodes.purify","page":"Code functions","title":"TensorNetworkCodes.purify","text":"purify(code::SimpleCode) -> SimpleCode\n\nGiven a simple code with k logicals on n physical qubits, return a new simple code with 0 logicals on n + k physical qubits.\n\nExamples\n\njulia> code = purify(five_qubit_code());\n\njulia> num_qubits(code), length(code.logicals)\n(6, 0)\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#Contraction","page":"Code functions","title":"Contraction","text":"","category":"section"},{"location":"api/code_functions/","page":"Code functions","title":"Code functions","text":"Functions to contract codes using the primitives of combining codes and fusing physical qubits.","category":"page"},{"location":"api/code_functions/","page":"Code functions","title":"Code functions","text":"combine\ncontract\ncontract_by_coords\nfusion","category":"page"},{"location":"api/code_functions/#TensorNetworkCodes.combine","page":"Code functions","title":"TensorNetworkCodes.combine","text":"combine(code1::SimpleCode, code2::SimpleCode) -> SimpleCode\ncombine(code1::TensorNetworkCode, code2::TensorNetworkCode) -> TensorNetworkCode\n\nReturn a new code that is the tensor product of the given codes. Physically equivalent to preparing two codes on different sets of physical qubits.\n\nExamples\n\njulia> code = combine(five_qubit_code(), steane_code());  # combine 5 and 7 qubit codes\n\njulia> num_qubits(code)\n12\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#TensorNetworkCodes.contract","page":"Code functions","title":"TensorNetworkCodes.contract","text":"contract(\n    code1::TensorNetworkCode,\n    code2::TensorNetworkCode,\n    qubit_pair::AbstractVector{Int}\n) -> TensorNetworkCode\n\ncontract(\n    code1::TensorNetworkCode,\n    code2::TensorNetworkCode,\n    qubit_pairs\n) -> TensorNetworkCode\n\nReturn a new code that results from combining the codes and fusing physical qubits identified by the qubit pairs. The first and second elements of a qubit pair refer to qubit labels from the first and second codes, respectively.\n\nThis is equivalent to combine followed by fusion, with the qubit pair labels referring to the code qubit labels before combining. The version that takes qubit_pairs takes iterables of AbstractVector{Int}. An ErrorException is thrown if the fusion is not possible.\n\nSee also: combine, fusion.\n\nExamples\n\njulia> code1 = TensorNetworkCode(five_qubit_code());\n\njulia> code2 = TensorNetworkCode(steane_code());\n\njulia> contracted_code = contract(code1, code2, [[1, 2], [2, 7]]);\n\njulia> num_qubits(contracted_code), length(contracted_code.logicals) ÷ 2\n(8, 2)\n\njulia> fusion(combine(code1, code2), [[1, 7], [2, 12]]);  # equivalent code\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#TensorNetworkCodes.contract_by_coords","page":"Code functions","title":"TensorNetworkCodes.contract_by_coords","text":"contract_by_coords(code1::TensorNetworkCode,code2::TensorNetworkCode)\n    -> TensorNetworkCode\n\nReturn a new code that results from combining the codes and fusing physical qubits with coincident coordinates.\n\nThis is equivalent to combine followed by fusion, with the fusion qubit pairs being those with coincident coordinates. An ErrorException is thrown if the fusion is not possible.\n\nSee also: combine, fusion.\n\nExamples\n\njulia> code1 = TensorNetworkCode(five_qubit_code());\n\njulia> code2 = TensorNetworkCode(steane_code());\n\njulia> set_coords!(code1, 1, [5, 5]); set_coords!(code2, 2, [5, 5]); # qubits 1 & 2 coincide\n\njulia> set_coords!(code1, 2, [6, 6]); set_coords!(code2, 7, [6, 6]); # qubits 2 & 7 coincide\n\njulia> contracted_code = contract_by_coords(code1, code2);\n\njulia> num_qubits(contracted_code), length(contracted_code.logicals) ÷ 2\n(8, 2)\n\njulia> contract(code1, code2, [[1, 2], [2, 7]]);  # equivalent code\n\n\n\n\n\n","category":"function"},{"location":"api/code_functions/#TensorNetworkCodes.fusion","page":"Code functions","title":"TensorNetworkCodes.fusion","text":"fusion(code::SimpleCode, qubit_pair::AbstractVector{Int}) -> SimpleCode\nfusion(code::SimpleCode, qubit_pairs) -> SimpleCode\n\nfusion(code::TensorNetworkCode, qubit_pair::AbstractVector{Int}) -> TensorNetworkCode\nfusion(code::TensorNetworkCode, qubit_pairs) -> TensorNetworkCode\n\nReturn a new code that results from fusing the physical qubits with labels given by each qubit pair. The new code has two fewer physical qubits, for each qubit pair, but the same number of logical qubits. Physically equivalent to updating stabilizers, logicals and pure errors after measuring XX and ZZ on each pair of qubits.\n\nThe versions that take qubit_pairs take iterables of AbstractVector{Int}. An ErrorException is thrown if the fusion is not possible, i.e., if the logical degrees of freedom would not be preserved by the measurements.\n\nExamples\n\njulia> code = steane_code();\n\njulia> num_qubits(code), length(code.logicals) ÷ 2\n(7, 1)\n\njulia> fused_code = fusion(code, [1, 2]);\n\njulia> num_qubits(fused_code), length(fused_code.logicals) ÷ 2\n(5, 1)\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"api/","page":"Index","title":"Index","text":"","category":"page"},{"location":"api/pauli_functions/#Pauli-functions","page":"Pauli functions","title":"Pauli functions","text":"","category":"section"},{"location":"api/pauli_functions/","page":"Pauli functions","title":"Pauli functions","text":"Pauli functions for evaluating products, commutations, weights and independence.","category":"page"},{"location":"api/pauli_functions/","page":"Pauli functions","title":"Pauli functions","text":"Single-qubit Pauli operators I, X, Y, Z are represented by integers 0, 1, 2, 3, respectively. Correspondingly, multi-qubit Pauli operators are represented by vectors of integers; for example, X  I  Z  Y is represented by [1, 0, 3, 2].","category":"page"},{"location":"api/pauli_functions/","page":"Pauli functions","title":"Pauli functions","text":"pauli_are_commuting\npauli_are_independent\npauli_commutation\npauli_pow\npauli_product\npauli_product_pow\npauli_random_operator\npauli_rep_change\npauli_weight","category":"page"},{"location":"api/pauli_functions/#TensorNetworkCodes.pauli_are_commuting","page":"Pauli functions","title":"TensorNetworkCodes.pauli_are_commuting","text":"pauli_are_commuting(operators) -> Bool\n\nReturn true if the Pauli operators mutually commute, or false otherwise, where operators is an iterable of AbstractVector{Int}.\n\nExamples\n\njulia> stabilizers = [[1, 3, 3, 1, 0], [0, 1, 3, 3, 1], [1, 0, 1, 3, 3], [3, 1, 0, 1, 3]];\n\njulia> pauli_are_commuting(stabilizers)  # stabilizers mutually commute\ntrue\n\njulia> logical_x, logical_z = [1, 1, 1, 1, 1], [3, 3, 3, 3, 3];  # XXXXX, ZZZZZ\n\njulia> pauli_are_commuting([logical_x, logical_z])  # logicals do not commute\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/pauli_functions/#TensorNetworkCodes.pauli_are_independent","page":"Pauli functions","title":"TensorNetworkCodes.pauli_are_independent","text":"pauli_are_independent(operators) -> Bool\n\nReturn true if the Pauli operators are independent, or false otherwise, where operators is an iterable of AbstractVector{Int}.  Here independence means that no operator can be expressed as a product of the others.\n\nExamples\n\njulia> pauli_are_independent([[3, 3, 0], [0, 3, 3]])  # ZZI, IZZ\ntrue\n\njulia> pauli_are_independent([[3, 3, 0], [0, 3, 3], [3, 0, 3]])  # ZZI, IZZ, ZIZ\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/pauli_functions/#TensorNetworkCodes.pauli_commutation","page":"Pauli functions","title":"TensorNetworkCodes.pauli_commutation","text":"pauli_commutation(a::Int, b::Int) -> 0 or 1\npauli_commutation(a::AbstractVector{Int}, b::AbstractVector{Int}) -> 0 or 1\n\nReturn the commutation relation of two Paulis, i.e. 0 if they commute and 1 if not.\n\nExamples\n\njulia> pauli_commutation(1, 1)  # X commutes with itself\n0\n\njulia> pauli_commutation(1, 3)  # X does not commute with Z\n1\n\njulia> pauli_commutation([1, 3, 3, 1, 0], [1, 1, 1, 1, 1])  # XZZXI commutes with XXXXX\n0\n\njulia> stabilizers = [[1, 3, 3, 1, 0], [0, 1, 3, 3, 1], [1, 0, 1, 3, 3], [3, 1, 0, 1, 3]];\n\njulia> error = [1, 1, 0, 0, 0];  # XXIII\n\njulia> syndrome = pauli_commutation.(stabilizers, Ref(error))\n4-element Vector{Int64}:\n 1\n 0\n 0\n 1\n\n\n\n\n\n","category":"function"},{"location":"api/pauli_functions/#TensorNetworkCodes.pauli_pow","page":"Pauli functions","title":"TensorNetworkCodes.pauli_pow","text":"pauli_pow(a::Int, power::Int) -> Int\n\nReturn the Pauli raised to the given power.\n\nExamples\n\njulia> x_squared = pauli_pow(1, 2)\n0\n\njulia> z_inverse = pauli_pow(3, -1)\n3\n\n\n\n\n\n","category":"function"},{"location":"api/pauli_functions/#TensorNetworkCodes.pauli_product","page":"Pauli functions","title":"TensorNetworkCodes.pauli_product","text":"pauli_product(a::Int, b::Int) -> Int\n\nReturn the product of two Paulis.  Note that we are ignoring overall minus signs.\n\nExamples\n\njulia> pauli_product(1, 2) # X.Y -> Z\n3\n\njulia> pauli_product.([1, 0, 3, 2], [1, 1, 1, 3]) # (XIZY).(XXXZ) -> (IXYX)\n4-element Vector{Int64}:\n 0\n 1\n 2\n 1\n\n\n\n\n\npauli_product(operators) -> Vector{Int}\n\nReturn the product of the Pauli operators, where operators is an iterable of AbstractVector{Int}.\n\nSee also pauli_product_pow.\n\nExamples\n\njulia> ops = [[3, 3, 0], [0, 1, 1], [2, 0, 2]];  # ZZI, IXX, YIY\n\njulia> pauli_product(ops)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"api/pauli_functions/#TensorNetworkCodes.pauli_product_pow","page":"Pauli functions","title":"TensorNetworkCodes.pauli_product_pow","text":"pauli_product_pow(operators, powers) -> Vector{Int}\n\nReturn the product of the Pauli operators each raised to the corresponding power, where operators is an iterable of AbstractVector{Int} and powers is an iterable of Int.\n\nNote: The product is evaluated to the length of the shorter of the two iterables.\n\nSee also pauli_product, pauli_pow.\n\nExamples\n\njulia> ops = [[3, 3, 0], [0, 1, 1], [2, 0, 2]];  # ZZI, IXX, YIY\n\njulia> pauli_product_pow(ops, [1, 0, 1])\n3-element Vector{Int64}:\n 1\n 3\n 2\n\n\n\n\n\n","category":"function"},{"location":"api/pauli_functions/#TensorNetworkCodes.pauli_random_operator","page":"Pauli functions","title":"TensorNetworkCodes.pauli_random_operator","text":"pauli_random_operator(n::Int, p::Real, rng::AbstractRNG=GLOBAL_RNG)\n    -> AbstractVector{Int}\n\nReturn a random Pauli operator on n qubits with Paulis applied according to i.i.d. depolarizing noise with probability p.\n\nExamples\n\njulia> using Random:MersenneTwister  # use RNG for reproducible example\n\njulia> pauli_random_operator(5, 0.2, MersenneTwister(13))\n5-element Vector{Int64}:\n 3\n 3\n 0\n 2\n 0\n\n\n\n\n\n","category":"function"},{"location":"api/pauli_functions/#TensorNetworkCodes.pauli_rep_change","page":"Pauli functions","title":"TensorNetworkCodes.pauli_rep_change","text":"pauli_rep_change(pauli::Int) -> Char\npauli_rep_change(pauli::Char) -> Int\n\nConvert Pauli between alphabetical and numerical representation.\n\nExamples\n\njulia> pauli_rep_change(1)\n'X': ASCII/Unicode U+0058 (category Lu: Letter, uppercase)\n\njulia> pauli_rep_change('X')\n1\n\njulia> pauli_rep_change.((0, 1, 2, 3))\n('I', 'X', 'Y', 'Z')\n\njulia> pauli_rep_change.(('I', 'X', 'Y', 'Z'))\n(0, 1, 2, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/pauli_functions/#TensorNetworkCodes.pauli_weight","page":"Pauli functions","title":"TensorNetworkCodes.pauli_weight","text":"pauli_weight(operator::AbstractVector{Int}) -> Int\n\nReturn the weight of the Pauli operator, i.e. the number of non-identity elements.\n\nExamples\n\njulia> pauli_weight([3, 0, 2, 0, 1])  # ZIYIX\n3\n\n\n\n\n\n","category":"function"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"Types representing quantum error correcting codes. An abstract type, QuantumCode, defines the contract for all codes. SimpleCode is a basic implementation that can be used as a seed code in a TensorNetworkCode, which has an associated CodeGraph.","category":"page"},{"location":"api/types/#Quantum-code","page":"Types","title":"Quantum code","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"QuantumCode","category":"page"},{"location":"api/types/#TensorNetworkCodes.QuantumCode","page":"Types","title":"TensorNetworkCodes.QuantumCode","text":"Abstract supertype for quantum error correcting codes.\n\nSubtypes should include the following fields:\n\nstabilizers::Vector{Vector{Int}}\nlogicals::Vector{Vector{Int}}\npure_errors::Vector{Vector{Int}}\n\nwhere stabilizers are a linearly independent collection of stabilizer generators, logicals are representatives of logical operators ordered as X-type, Z-type, ... for each logical qubit, and pure_errors (or destabilizers) are operators the anticommute with the corresponding stabilizer generator and commute with all other stabilizer generators. Each of stabilizers, logicals and pure_errors are collections of multi-qubit Pauli operators, see Pauli functions. The relationships between the operators can be checked using verify.\n\nnote: Note\nTransformation and contraction functions do not modify stabilizers, logicals or pure_errors fields directly but rather return new codes. Therefore these fields can be treated as immutable.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Simple-code","page":"Types","title":"Simple code","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"SimpleCode\nSimpleCode()\nSimpleCode(name, stabilizers, logicals)\nSimpleCode(::TensorNetworkCode)","category":"page"},{"location":"api/types/#TensorNetworkCodes.SimpleCode","page":"Types","title":"TensorNetworkCodes.SimpleCode","text":"SimpleCode <: QuantumCode\n\nSimpleCode(name, stabilizers, logicals, pure_errors)\n\nSimple named implementation of a quantum code.\n\nFields in addition to QuantumCode:\n\nname::String\n\nThis code contains no information on physical qubit layout but it can be used as a seed code in a TensorNetworkCode.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#TensorNetworkCodes.SimpleCode-Tuple{}","page":"Types","title":"TensorNetworkCodes.SimpleCode","text":"SimpleCode()\n\nConstruct an empty simple code with empty string name.\n\n\n\n\n\n","category":"method"},{"location":"api/types/#TensorNetworkCodes.SimpleCode-Tuple{Any, Any, Any}","page":"Types","title":"TensorNetworkCodes.SimpleCode","text":"SimpleCode(name, stabilizers, logicals)\n\nConstruct a simple code with pure errors evaluated using find_pure_errors.\n\nAn ErrorException is thrown if the pure errors cannot be evaluated; for example, if the stabilizers are not linearly independent.\n\nExamples\n\njulia> code = SimpleCode(\n           \"5-qubit code\",\n           [[1, 3, 3, 1, 0], [0, 1, 3, 3, 1], [1, 0, 1, 3, 3], [3, 1, 0, 1, 3]],\n           [[1, 1, 1, 1, 1], [3, 3, 3, 3, 3]]\n       );\n\njulia> code.pure_errors\n4-element Vector{Vector{Int64}}:\n [0, 1, 0, 0, 0]\n [1, 3, 0, 0, 0]\n [3, 1, 0, 0, 0]\n [1, 0, 0, 0, 0]\n\njulia> verify(code)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/types/#TensorNetworkCodes.SimpleCode-Tuple{TensorNetworkCode}","page":"Types","title":"TensorNetworkCodes.SimpleCode","text":" SimpleCode(code::TensorNetworkCode)\n\nConstruct a simple code from a tensor-network code with an empty string name.\n\nThe constructed code shares the stabilizers, logicals and pure_errors with the given code.\n\nSee also TensorNetworkCode.\n\n\n\n\n\n","category":"method"},{"location":"api/types/#Tensor-network-code","page":"Types","title":"Tensor-network code","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"CodeGraph\nTensorNetworkCode\nTensorNetworkCode(::SimpleCode)","category":"page"},{"location":"api/types/#TensorNetworkCodes.CodeGraph","page":"Types","title":"TensorNetworkCodes.CodeGraph","text":"CodeGraph\n\nType aggregating all geometrical data used by TensorNetworkCode, including coordinates and ITensor indices.\n\nSee also TensorNetworkCode.\n\nnote: Note\nCodeGraph is not typically accessed directly but rather created, read and updated using Transformation, Contraction and Code graph functions.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#TensorNetworkCodes.TensorNetworkCode","page":"Types","title":"TensorNetworkCodes.TensorNetworkCode","text":"TensorNetworkCode <: QuantumCode\n\nTensorNetworkCode(stabilizers, logicals, pure_errors, code_graph, seed_codes)\n\nTensor-network implementation of a quantum code, with associated code graph and seed codes.\n\nFields in addition to QuantumCode:\n\ncode_graph::CodeGraph\nseed_codes::Dict{String,SimpleCode}\n\nThe code_graph contains information on physical qubit layout. The seed_codes are simple codes that are used to build the tensor-network code.\n\nSee also CodeGraph.\n\nnote: Note\nThe code_graph and seed_codes fields are not typically accessed directly but rather read and updated using Transformation, Contraction and Code graph functions.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#TensorNetworkCodes.TensorNetworkCode-Tuple{SimpleCode}","page":"Types","title":"TensorNetworkCodes.TensorNetworkCode","text":"TensorNetworkCode(code::SimpleCode)\n\nConstruct a tensor-network code from a seed simple code and initialize the code graph with with appropriate defaults.\n\nThe constructed code shares the stabilizers, logicals and pure_errors with the given code.\n\nSee also SimpleCode.\n\nExamples\n\njulia> simple_code = five_qubit_code();\n\njulia> tn_code = TensorNetworkCode(simple_code);\n\njulia> verify(tn_code)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/TNDistance/#TNDistance-module","page":"TNDistance module","title":"TNDistance module","text":"","category":"section"},{"location":"api/TNDistance/","page":"TNDistance module","title":"TNDistance module","text":"CurrentModule = TensorNetworkCodes.TNDistance","category":"page"},{"location":"api/TNDistance/","page":"TNDistance module","title":"TNDistance module","text":"TNDistance","category":"page"},{"location":"api/TNDistance/#TensorNetworkCodes.TNDistance","page":"TNDistance module","title":"TensorNetworkCodes.TNDistance","text":"Calculate distances and distributions of logical operator and stabilizer weights for a TensorNetworkCode, see tn_distance and tn_operator_weights.\n\n\n\n\n\n","category":"module"},{"location":"api/TNDistance/#Operator-Weights","page":"TNDistance module","title":"Operator Weights","text":"","category":"section"},{"location":"api/TNDistance/","page":"TNDistance module","title":"TNDistance module","text":"TNDistance.OperatorWeights","category":"page"},{"location":"api/TNDistance/#TensorNetworkCodes.TNDistance.OperatorWeights","page":"TNDistance module","title":"TensorNetworkCodes.TNDistance.OperatorWeights","text":"OperatorWeights(stabilizer_weights,all_operator_weights)\n\nStores operator weight distribution for stabilizers and all code operators (stabilizers + all logical representatives).  Also stores distance.  Fields:\n\nstabilizer_weights::Array{Int64,1}\nall_operator_weights::Array{Int64,1}\ndistance::Int64\n\nNote that since julia is 1-indexed stabilizer_weights[j] gives the number of stabilizers of weight j-1.\n\n\n\n\n\n","category":"type"},{"location":"api/TNDistance/#Distance-and-Operator-Weight-functions","page":"TNDistance module","title":"Distance and Operator Weight functions","text":"","category":"section"},{"location":"api/TNDistance/","page":"TNDistance module","title":"TNDistance module","text":"TNDistance.tn_operator_weights\nTNDistance.tn_distance\nTNDistance.plot_operator_weights","category":"page"},{"location":"api/TNDistance/#TensorNetworkCodes.TNDistance.tn_operator_weights","page":"TNDistance module","title":"TensorNetworkCodes.TNDistance.tn_operator_weights","text":"tn_operator_weights(code::TensorNetworkCode;truncate_to=num_qubits(code)+1)\n-> OperatorWeights\n\nReturns OperatorWeights which includes the number of stabilizers of each weight, as well as the number of logical representatives (excluding identity) of each weight, as well as the code distance.\n\nExamples\n\njulia> using TensorNetworkCodes.TNDistance\n\njulia> code = TensorNetworkCode(five_qubit_code());\n\njulia> code = contract(code,code,[[1,1],[3,3]]);\n\njulia> tn_operator_weights(code)\nOperatorWeights([1, 0, 0, 0, 9, 0, 6], [1, 0, 9, 24, 99, 72, 51], 2)\n\n\n\n\n\n","category":"function"},{"location":"api/TNDistance/#TensorNetworkCodes.TNDistance.tn_distance","page":"TNDistance module","title":"TensorNetworkCodes.TNDistance.tn_distance","text":"tn_distance(code::TensorNetworkCode;truncate_to=num_qubits(code)+1)\n-> Int64\n\nReturns the code distance calculated by contracting a tensor network.  Returns zero for stabilizer states (codes with no logical qubits).\n\nExamples\n\njulia> using TensorNetworkCodes.TNDistance\n\njulia> code = TensorNetworkCode(steane_code());\n\njulia> code = contract(code,code,[[1,1],[3,3]]); # contract two copies\n\njulia> tn_distance(code) # this code has poor distance!\n2\n\n\n\n\n\n","category":"function"},{"location":"api/TNDistance/#TensorNetworkCodes.TNDistance.plot_operator_weights","page":"TNDistance module","title":"TensorNetworkCodes.TNDistance.plot_operator_weights","text":"plot_operator_weights(\n    weights::OperatorWeights; truncate_to=length(weights.stabilizer_weights)\n)\n\nPlots a bar plot (on a log scale) of the number of operators of each weight. This includes all code operators (logicals plus stabilizers) and all stabilizers plotted separately.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#Code-graph-functions","page":"Code graph functions","title":"Code graph functions","text":"","category":"section"},{"location":"api/code_graph_functions/","page":"Code graph functions","title":"Code graph functions","text":"Functions to access and manipulate the CodeGraph associated with a TensorNetworkCode.","category":"page"},{"location":"api/code_graph_functions/#Introductory-notes","page":"Code graph functions","title":"Introductory notes","text":"","category":"section"},{"location":"api/code_graph_functions/","page":"Code graph functions","title":"Code graph functions","text":"Node labels are of type Int with negative and positive integers representing virtual nodes and physical qubits, respectively.\nEdge labels are of type Set{Int} and contain two elements corresponding to the labels of the nodes that the edge links.\nNode coordinates are of type Vector{<:Real} and contain two elements corresponding to 2-dimensional Cartesian coordinates.\nNode types are of type String and can take the values: \"physical\" for physical qubits or else they take the name of a seed code for virtual nodes, e.g., \"Five qubit code\".\nEdge types are of type String and can take the values: \"physical\" for an edge between a virtual node and physical (i.e., qubit) node or \"bond\" for an edge between two virtual nodes, e.g., as occurs after contracting a \"Five qubit code\" and a \"Steane code\".\nEdge indices are of type Vector{ITensors.Index{Int64}}}.  These are lists of the indices necessary for tensor-network contraction (e.g., for decoding).\nNode indices are also of type Vector{ITensors.Index{Int64}}}.  These indices match the indices on the incident edges to that node.  This is necessary for, e.g., tensor-network decoding: when a tensor is created at a node, the first index in the list of node indices corresponds to the first qubit of the seed code, and so on.","category":"page"},{"location":"api/code_graph_functions/#Specialized-functions","page":"Code graph functions","title":"Specialized functions","text":"","category":"section"},{"location":"api/code_graph_functions/","page":"Code graph functions","title":"Code graph functions","text":"edges\nnew_indices\nnodes\nnum_nodes\nphysical_neighbours\nset_coords!(::TensorNetworkCode, ::AbstractVector{<:AbstractVector{<:Real}})\nshift_coords!(::TensorNetworkCode, ::AbstractVector{<:Real})","category":"page"},{"location":"api/code_graph_functions/#TensorNetworkCodes.edges","page":"Code graph functions","title":"TensorNetworkCodes.edges","text":"edges(code) -> Vector{Set{Int}}\n\nReturns a list of edge labels for the code, corresponding to edges between nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.new_indices","page":"Code graph functions","title":"TensorNetworkCodes.new_indices","text":"new_indices(code::TensorNetworkCode) -> TensorNetworkCode\n\nDeepcopies the code but changes all ITensor indices.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.nodes","page":"Code graph functions","title":"TensorNetworkCodes.nodes","text":"nodes(code::TensorNetworkCode) -> Vector{Int}\n\nReturns an ordered list of node labels for the code, corresponding to the qubits and virtual nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.num_nodes","page":"Code graph functions","title":"TensorNetworkCodes.num_nodes","text":"num_nodes(code::TensorNetworkCode) -> Int\n\nReturns the number of nodes in the code, which is the sum of the number of qubits and the number of virtual nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.physical_neighbours","page":"Code graph functions","title":"TensorNetworkCodes.physical_neighbours","text":"physical_neighbours(code::TensorNetworkCode, node::Int) -> Set{Int}\n\nReturns the node labels of physical qubits connected by an edge to the given node.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.set_coords!-Tuple{TensorNetworkCode, AbstractVector{<:AbstractVector{<:Real}}}","page":"Code graph functions","title":"TensorNetworkCodes.set_coords!","text":"set_coords!(\n    code::TensorNetworkCode,\n    new_coords::AbstractVector{<:AbstractVector{<:Real}}\n)\n\nAssign new coordinates to all (physical and virtual) nodes of the code, where the order of the coordinates matches that of the nodes returned by nodes, i.e. in ascending order.\n\n\n\n\n\n","category":"method"},{"location":"api/code_graph_functions/#TensorNetworkCodes.shift_coords!-Tuple{TensorNetworkCode, AbstractVector{<:Real}}","page":"Code graph functions","title":"TensorNetworkCodes.shift_coords!","text":"shift_coords!(code::TensorNetworkCode, shift::AbstractVector{<:Real})\n\nShift the coordinates of all (physical and virtual) nodes of the code by the given shift.\n\n\n\n\n\n","category":"method"},{"location":"api/code_graph_functions/#Generic-getters-/-setters","page":"Code graph functions","title":"Generic getters / setters","text":"","category":"section"},{"location":"api/code_graph_functions/","page":"Code graph functions","title":"Code graph functions","text":"coords\nset_coords!(::TensorNetworkCode, ::Int, ::Any)\nedge_indices\nset_edge_indices!\nedge_types\nset_edge_types!\nnode_indices\nset_node_indices!\nnode_types\nset_node_types!","category":"page"},{"location":"api/code_graph_functions/#TensorNetworkCodes.coords","page":"Code graph functions","title":"TensorNetworkCodes.coords","text":"coords(code::TensorNetworkCode)\n\nReturn coords field of the code's CodeGraph.\n\n\n\n\n\ncoords(code::TensorNetworkCode, label::Int)\n\nReturn coords[label] for the node from the code's CodeGraph.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.set_coords!-Tuple{TensorNetworkCode, Int64, Any}","page":"Code graph functions","title":"TensorNetworkCodes.set_coords!","text":"set_coords!(code::TensorNetworkCode, label::Int, new_data)\n\nSet coords[label] for the node from the code's CodeGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/code_graph_functions/#TensorNetworkCodes.edge_indices","page":"Code graph functions","title":"TensorNetworkCodes.edge_indices","text":"edge_indices(code::TensorNetworkCode)\n\nReturn edge_indices field of the code's CodeGraph.\n\n\n\n\n\nedge_indices(code::TensorNetworkCode, label::Set{Int})\n\nReturn edge_indices[label] for the edge from the code's CodeGraph.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.set_edge_indices!","page":"Code graph functions","title":"TensorNetworkCodes.set_edge_indices!","text":"set_edge_indices!(code::TensorNetworkCode, label::Set{Int}, new_data)\n\nSet edge_indices[label] for the edge from the code's CodeGraph.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.edge_types","page":"Code graph functions","title":"TensorNetworkCodes.edge_types","text":"edge_types(code::TensorNetworkCode)\n\nReturn edge_types field of the code's CodeGraph.\n\n\n\n\n\nedge_types(code::TensorNetworkCode, label::Set{Int})\n\nReturn edge_types[label] for the edge from the code's CodeGraph.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.set_edge_types!","page":"Code graph functions","title":"TensorNetworkCodes.set_edge_types!","text":"set_edge_types!(code::TensorNetworkCode, label::Set{Int}, new_data)\n\nSet edge_types[label] for the edge from the code's CodeGraph.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.node_indices","page":"Code graph functions","title":"TensorNetworkCodes.node_indices","text":"node_indices(code::TensorNetworkCode)\n\nReturn node_indices field of the code's CodeGraph.\n\n\n\n\n\nnode_indices(code::TensorNetworkCode, label::Int)\n\nReturn node_indices[label] for the node from the code's CodeGraph.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.set_node_indices!","page":"Code graph functions","title":"TensorNetworkCodes.set_node_indices!","text":"set_node_indices!(code::TensorNetworkCode, label::Int, new_data)\n\nSet node_indices[label] for the node from the code's CodeGraph.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.node_types","page":"Code graph functions","title":"TensorNetworkCodes.node_types","text":"node_types(code::TensorNetworkCode)\n\nReturn node_types field of the code's CodeGraph.\n\n\n\n\n\nnode_types(code::TensorNetworkCode, label::Int)\n\nReturn node_types[label] for the node from the code's CodeGraph.\n\n\n\n\n\n","category":"function"},{"location":"api/code_graph_functions/#TensorNetworkCodes.set_node_types!","page":"Code graph functions","title":"TensorNetworkCodes.set_node_types!","text":"set_node_types!(code::TensorNetworkCode, label::Int, new_data)\n\nSet node_types[label] for the node from the code's CodeGraph.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Overview","title":"Overview","text":"CurrentModule = TensorNetworkCodes","category":"page"},{"location":"#TensorNetworkCodes.jl","page":"Overview","title":"TensorNetworkCodes.jl","text":"","category":"section"},{"location":"#Introduction","page":"Overview","title":"Introduction","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"TensorNetworkCodes.jl is a Julia library developed to support the following research:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"T. Farrelly, D. K. Tuckett, T. M. Stace, Local tensor-network codes, arXiv:2109.11996, (2021).","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"TensorNetworkCodes.jl is installed, like any other registered Julia package, using the Julia package manager Pkg:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"pkg> add TensorNetworkCodes  # Press ']' to enter the Pkg REPL mode.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"or","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> using Pkg; Pkg.add(\"TensorNetworkCodes\")","category":"page"},{"location":"#Demos","page":"Overview","title":"Demos","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The following demos correspond to results included in arXiv:2109.11996:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Small example tensor-network codes and code distances\nThe 19 qubit colour code as a tensor-network code\nThe modified surface code","category":"page"},{"location":"#Citing","page":"Overview","title":"Citing","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Please cite TensorNetworkCodes.jl if you use it in your research.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A suitable BibTeX entry is:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"@article{Farrelly_LocalTNCodes_2021,\n    title = {Local tensor-network codes},\n    author = {Farrelly, Terry and Tuckett, David K. and Stace, Thomas M.},\n    year = {2021},\n    archiveprefix = {arXiv},\n    eprint = {2109.11996},\n    url = {https://arxiv.org/abs/2109.11996},\n}","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Similarly, please cite Qecsim.jl if you use its features in your research, see Qecsim.jl Documentation for details.","category":"page"},{"location":"#License","page":"Overview","title":"License","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"TensorNetworkCodes.jl is released under the BSD 3-Clause license, see LICENSE.","category":"page"},{"location":"#Links","page":"Overview","title":"Links","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Source code: https://github.com/qecsim/TensorNetworkCodes.jl\nDocumentation: https://qecsim.github.io/TensorNetworkCodes.jl\nContact: TODO: add contact email","category":"page"}]
}
